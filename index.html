<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>픽셀 던전 히어로: 어웨이크닝</title>
    
    <!-- Libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        body { 
            background-color: #050505; 
            color: white; 
            overflow: hidden; 
            font-family: 'Courier New', monospace;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }
        .pixel-art { image-rendering: pixelated; }
        
        /* Effects */
        @keyframes shake {
            0% { transform: translate(0, 0) rotate(0deg); }
            20% { transform: translate(-3px, 3px) rotate(-5deg); }
            40% { transform: translate(3px, -3px) rotate(5deg); }
            60% { transform: translate(-3px, -3px) rotate(-5deg); }
            80% { transform: translate(3px, 3px) rotate(5deg); }
            100% { transform: translate(0, 0) rotate(0deg); }
        }
        .shake { animation: shake 0.2s; }
        
        @keyframes dash-blur {
            0% { opacity: 0.5; transform: scale(1); filter: blur(0px); }
            50% { opacity: 0.8; transform: scale(1.1); filter: blur(2px); }
            100% { opacity: 0; transform: scale(1); filter: blur(4px); }
        }
        .dash-effect { animation: dash-blur 0.3s forwards; }

        @keyframes float-up {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-40px) scale(1.5); opacity: 0; }
        }
        .float-anim { animation: float-up 0.8s ease-out forwards; }
        
        @keyframes skill-nova {
            0% { transform: scale(0); opacity: 0.8; }
            100% { transform: scale(4); opacity: 0; }
        }
        .skill-nova { animation: skill-nova 0.5s ease-out forwards; }

        @keyframes target-bounce {
            0%, 100% { transform: translate(-50%, -20%); }
            50% { transform: translate(-50%, -40%); }
        }
        .target-indicator { animation: target-bounce 0.8s infinite; }

        /* Mobile Controls */
        .d-pad-btn {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            display: flex; align-items: center; justify-content: center;
            color: rgba(255, 255, 255, 0.6);
            transition: all 0.1s;
            cursor: pointer;
        }
        .d-pad-btn:active, .d-pad-btn.active {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(0.95);
            border-color: rgba(255, 255, 255, 0.5);
            color: white;
        }
        .action-btn {
            backdrop-filter: blur(4px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            transition: transform 0.1s;
            cursor: pointer;
        }
        .action-btn:active { transform: scale(0.85); filter: brightness(1.2); }

        /* Biome Backgrounds */
        .bg-pattern {
            background-image: 
                linear-gradient(rgba(255,255,255,0.03) 1px, transparent 1px), 
                linear-gradient(90deg, rgba(255,255,255,0.03) 1px, transparent 1px);
            background-size: 40px 40px;
        }
    </style>
<script type="importmap">
{
  "imports": {
    "@react-three/fiber": "https://aistudiocdn.com/@react-three/fiber@^9.4.0",
    "zustand": "https://aistudiocdn.com/zustand@^5.0.8",
    "@react-three/drei": "https://aistudiocdn.com/@react-three/drei@^10.7.7",
    "three": "https://aistudiocdn.com/three@^0.181.2",
    "uuid": "https://aistudiocdn.com/uuid@^13.0.0",
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "lucide-react": "https://aistudiocdn.com/lucide-react@^0.554.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "@react-three/postprocessing": "https://aistudiocdn.com/@react-three/postprocessing@^3.0.4"
  }
}
</script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo, useCallback } = React;

        // --- Sound System ---
        // Safe AudioContext creation
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = AudioContext ? new AudioContext() : null;
        
        const playSound = (type) => {
            if (!audioCtx) return;
            if (audioCtx.state === 'suspended') audioCtx.resume().catch(e => console.log(e));
            
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            const now = audioCtx.currentTime;

            switch (type) {
                case 'hit':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(100, now);
                    osc.frequency.exponentialRampToValueAtTime(10, now + 0.1);
                    gainNode.gain.setValueAtTime(0.1, now);
                    gainNode.gain.linearRampToValueAtTime(0, now + 0.1);
                    osc.start(now); osc.stop(now + 0.1);
                    break;
                case 'shoot':
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(800, now);
                    osc.frequency.exponentialRampToValueAtTime(100, now + 0.3);
                    gainNode.gain.setValueAtTime(0.05, now);
                    gainNode.gain.linearRampToValueAtTime(0, now + 0.3);
                    osc.start(now); osc.stop(now + 0.3);
                    break;
                case 'dash':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(600, now);
                    osc.frequency.linearRampToValueAtTime(200, now + 0.2);
                    gainNode.gain.setValueAtTime(0.1, now);
                    gainNode.gain.linearRampToValueAtTime(0, now + 0.2);
                    osc.start(now); osc.stop(now + 0.2);
                    break;
                case 'coin':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(1200, now);
                    osc.frequency.setValueAtTime(1800, now + 0.05);
                    gainNode.gain.setValueAtTime(0.05, now);
                    gainNode.gain.linearRampToValueAtTime(0, now + 0.1);
                    osc.start(now); osc.stop(now + 0.1);
                    break;
                case 'skill':
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(200, now);
                    osc.frequency.linearRampToValueAtTime(800, now + 0.5);
                    gainNode.gain.setValueAtTime(0.1, now);
                    gainNode.gain.linearRampToValueAtTime(0, now + 0.5);
                    osc.start(now); osc.stop(now + 0.5);
                    break;
                case 'levelup':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(400, now);
                    osc.frequency.setValueAtTime(600, now + 0.1);
                    osc.frequency.setValueAtTime(800, now + 0.2);
                    gainNode.gain.setValueAtTime(0.1, now);
                    gainNode.gain.linearRampToValueAtTime(0, now + 0.4);
                    osc.start(now); osc.stop(now + 0.4);
                    break;
            }
        };

        // --- Icons ---
        const Icon = ({ d, color = "currentColor", size = 24, fill = "none", className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill={fill} stroke={color} strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d={d} />
            </svg>
        );

        const Icons = {
            Sword: (p) => <Icon {...p} d="M14.5 17.5L3 6V3h3l11.5 11.5m-1.5 1.5l6-6M16 16l4 4M19 21l2-2" />,
            Bow: (p) => <Icon {...p} d="M12 2a10 10 0 0 0 0 20M12 2v20M2 12h20" />,
            Staff: (p) => <Icon {...p} d="m2 22 20-20m-2 2a2 2 0 1 0 2.8-2.8 2 2 0 0 0-2.8 2.8z" />,
            Dagger: (p) => <Icon {...p} d="M14.5 9.5 19 5l-2.5-2.5L12 7l-9 9 2.5 2.5 9-9Z" />, 
            Shield: (p) => <Icon {...p} d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10" />,
            Heart: (p) => <Icon {...p} d="M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z" />,
            Zap: (p) => <Icon {...p} d="M13 2L3 14h9l-1 8 10-12h-9l1-8z" />,
            Skull: (p) => <Icon {...p} d="m12.5 17-.5-1-.5 1h1zM15 22a1 1 0 0 0 1-1v-1a2 2 0 0 0 1.56-3.25 8 8 0 1 0-11.12 0A2 2 0 0 0 8 20v1a1 1 0 0 0 1 1z" />,
            Coin: (p) => <Icon {...p} d="M12 22a10 10 0 1 0 0-20 10 10 0 0 0 0 20z" />,
            Shop: (p) => <Icon {...p} d="M3 3h2l.4 2M7 13h10l4-8H5.4M7 13L5.4 5M7 13l-2.293 2.293c-.63.63-.184 1.707.707 1.707H17m0 0a2 2 0 1 0 0 4 2 2 0 0 0 0-4zm-8 2a2 2 0 1 1 0 4 2 2 0 0 1 0-4z" />,
            Crosshair: (p) => <Icon {...p} d="M12 2v20M2 12h20M12 12a2 2 0 1 0 0-4 2 2 0 0 0 0 4z" />,
            Wind: (p) => <Icon {...p} d="M9.59 4.59A2 2 0 1 1 11 8H2m10.59 11.41A2 2 0 1 0 14 16H2m15.73-8.27A2.5 2.5 0 1 1 19.5 12H2" />, 
            Ring: (p) => <Icon {...p} d="M12 2a10 10 0 1 0 0 20 10 10 0 0 0 0-20z M12 6a6 6 0 1 1 0 12 6 6 0 0 1 0-12z" />, 
            Boot: (p) => <Icon {...p} d="M4 19a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8a2 2 0 0 0-1-1.73l-4-2.3a2 2 0 0 0-2 0l-4 2.3A2 2 0 0 0 8 11v8z" />, 
            X: (p) => <Icon {...p} d="M18 6 6 18M6 6l12 12" />,
            RotateCcw: (p) => <Icon {...p} d="M3 2v6h6M3 13a9 9 0 1 0 3-7.7L3 8" />,
            Check: (p) => <Icon {...p} d="M20 6 9 17l-5-5" />,
            Target: (p) => <Icon {...p} d="M12 2a10 10 0 1 0 0 20 10 10 0 0 0 0-20zm0 4a6 6 0 1 1 0 12 6 6 0 0 1 0-12zm-3 6h6m-3-3v6" />, 
            ArrowUp: (p) => <Icon {...p} d="M12 19V5M5 12l7-7 7 7" />,
            ArrowDown: (p) => <Icon {...p} d="M12 5v14M19 12l-7 7-7-7" />,
            ArrowLeft: (p) => <Icon {...p} d="M19 12H5M12 19l-7-7 7-7" />,
            ArrowRight: (p) => <Icon {...p} d="M5 12h14M12 5l7 7-7 7" />
        };

        // --- Config ---
        const GAME_WIDTH = 800;
        const GAME_HEIGHT = 600;
        const PLAYER_SIZE = 32;

        const CLASSES = {
            knight: { name: '기사', hp: 150, mp: 40, atk: 12, speed: 4, color: '#60a5fa', desc: '튼튼한 맷집과 무적 스킬', weapon: 'sword', skillName: '디바인 쉴드' },
            hunter: { name: '헌터', hp: 90, mp: 60, atk: 18, speed: 5.5, color: '#4ade80', desc: '광역 화살비와 빠른 속도', weapon: 'bow', skillName: '화살비' },
            wizard: { name: '마법사', hp: 70, mp: 120, atk: 25, speed: 4, color: '#c084fc', desc: '강력한 체인 라이트닝', weapon: 'staff', skillName: '체인 라이트닝' },
            assassin: { name: '어쌔신', hp: 80, mp: 50, atk: 30, speed: 6, color: '#f43f5e', desc: '치명타와 순간이동', weapon: 'dagger', skillName: '그림자 습격' }
        };

        const ARTIFACTS = [
            { id: 'vampire', name: '흡혈의 송곳니', desc: '공격 시 체력 3 회복', icon: Icons.Heart, color: '#ef4444' },
            { id: 'hermes', name: '헤르메스 부츠', desc: '이동 속도 20% 증가', icon: Icons.Boot, color: '#fbbf24' },
            { id: 'multishot', name: '멀티 샷', desc: '투사체 +1 발사', icon: Icons.Bow, color: '#4ade80' },
            { id: 'berserk', name: '광전사의 도끼', desc: '공격력 30% 증가', icon: Icons.Sword, color: '#ef4444' },
            { id: 'mana', name: '마나 수정', desc: '마나 재생 속도 2배', icon: Icons.Zap, color: '#60a5fa' }
        ];

        // --- Main Component ---
        function App() {
            const [gameState, setGameState] = useState('SELECT_CLASS');
            const [floor, setFloor] = useState(1);
            const [player, setPlayer] = useState({ 
                x: 0, y: 0, hp: 100, maxHp: 100, mp: 50, maxMp: 50, 
                level: 1, exp: 0, maxExp: 100, gold: 0, 
                atk: 10, speed: 4, classType: 'knight', direction: 'down',
                artifacts: [] 
            });
            const [enemies, setEnemies] = useState([]);
            const [projectiles, setProjectiles] = useState([]);
            const [particles, setParticles] = useState([]);
            const [logs, setLogs] = useState([]);
            const [bossActive, setBossActive] = useState(false);
            const [showShop, setShowShop] = useState(false);
            const [shopItems, setShopItems] = useState([]);

            const stateRef = useRef({
                player: {},
                enemies: [],
                projectiles: [],
                particles: [],
                keys: {},
                floor: 1,
                lastShot: 0,
                lastSkill: 0,
                lastDash: 0,
                gameActive: false,
                invincible: 0 
            });

            const loopRef = useRef(null);
            const containerRef = useRef(null);

            const addLog = (msg) => setLogs(p => [msg, ...p].slice(0, 4));
            
            const spawnParticle = (x, y, type, value, color) => {
                stateRef.current.particles.push({ 
                    id: Math.random(), x, y, type, value, color, 
                    vx: (Math.random()-0.5)*2, vy: -1 - Math.random(), life: 60 
                });
            };

            const getBiomeStyle = (f) => {
                const biomeIndex = Math.floor((f - 1) / 5) % 3;
                if (biomeIndex === 0) return { bg: '#111', wall: '#444', name: '지하 감옥' };
                if (biomeIndex === 1) return { bg: '#0f291e', wall: '#1a4731', name: '이끼 숲' };
                return { bg: '#290f0f', wall: '#471a1a', name: '용암 동굴' };
            };

            const getStats = () => {
                const p = stateRef.current.player;
                if (!p || !p.artifacts) return { speed: 4, atk: 10 };
                const hasArt = (id) => p.artifacts.includes(id);
                
                let speed = p.speed * (hasArt('hermes') ? 1.2 : 1);
                let atk = p.atk * (hasArt('berserk') ? 1.3 : 1);
                
                return { speed, atk };
            };

            const getNearestEnemy = () => {
                const p = stateRef.current.player;
                let nearest = null;
                let minD = Infinity;
                stateRef.current.enemies.forEach(e => {
                    const dx = (e.x + e.width/2) - (p.x + PLAYER_SIZE/2);
                    const dy = (e.y + e.height/2) - (p.y + PLAYER_SIZE/2);
                    const d = dx*dx + dy*dy;
                    if (d < minD) {
                        minD = d;
                        nearest = e;
                    }
                });
                return nearest;
            };

            const initGame = (classType) => {
                // Ensure Audio Context is active on user interaction
                if (audioCtx && audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }

                const stats = CLASSES[classType];
                const initialPlayer = {
                    x: GAME_WIDTH / 2, y: GAME_HEIGHT / 2,
                    hp: stats.hp, maxHp: stats.hp,
                    mp: stats.mp, maxMp: stats.mp,
                    atk: stats.atk, baseSpeed: stats.speed, speed: stats.speed,
                    level: 1, exp: 0, maxExp: 100, gold: 0,
                    classType: classType,
                    direction: 'down',
                    isHit: 0,
                    artifacts: []
                };
                
                // Reset all state completely
                setPlayer(initialPlayer);
                setFloor(1);
                setEnemies([]);
                setProjectiles([]);
                setParticles([]);
                setLogs([`던전에 입장했습니다. [${CLASSES[classType].name}]`]);
                setBossActive(false);
                setShowShop(false);

                stateRef.current = {
                    player: initialPlayer,
                    enemies: [],
                    projectiles: [],
                    particles: [],
                    floor: 1,
                    gameActive: true,
                    keys: {}, // Clear keys to prevent sticking
                    invincible: 0,
                    lastShot: 0,
                    lastSkill: 0,
                    lastDash: 0
                };
                
                setGameState('PLAYING');
            };

            const resetGame = () => {
                if (loopRef.current) cancelAnimationFrame(loopRef.current);
                stateRef.current.gameActive = false;
                stateRef.current.keys = {}; // Clear input
                setGameState('SELECT_CLASS');
            };

            const openShop = () => {
                const available = ARTIFACTS.filter(a => !stateRef.current.player.artifacts.includes(a.id));
                const shop = [];
                shop.push({ type: 'potion', name: '회복 포션', desc: '체력 50% 회복', cost: 50, icon: Icons.Heart, color: '#f43f5e' });
                for(let i=0; i<2; i++) {
                    if (available.length > 0) {
                        const idx = Math.floor(Math.random() * available.length);
                        const art = available[idx];
                        shop.push({ type: 'artifact', ...art, cost: 150 + stateRef.current.floor * 50 });
                        available.splice(idx, 1);
                    }
                }
                setShopItems(shop);
                setShowShop(true);
                stateRef.current.gameActive = false;
            };

            const buyItem = (item) => {
                const p = stateRef.current.player;
                if (p.gold >= item.cost) {
                    p.gold -= item.cost;
                    if (item.type === 'potion') {
                        p.hp = Math.min(p.maxHp, p.hp + p.maxHp * 0.5);
                        addLog('물약 구매 완료');
                    } else if (item.type === 'artifact') {
                        p.artifacts.push(item.id);
                        addLog(`${item.name} 획득!`);
                    }
                    setPlayer({ ...p });
                    setShopItems(prev => prev.filter(i => i !== item));
                    playSound('coin');
                } else {
                    addLog('골드가 부족합니다!');
                }
            };

            const closeShop = () => {
                setShowShop(false);
                stateRef.current.gameActive = true;
            };

            const spawnEnemy = (isBoss) => {
                const floorMult = stateRef.current.floor;
                const biome = Math.floor((floorMult - 1) / 5) % 3;
                
                let type = 'SLIME';
                if (biome === 1) type = 'GOBLIN';
                if (biome === 2) type = 'DEMON';
                if (isBoss) type = 'BOSS';

                const edge = Math.floor(Math.random() * 4);
                let x, y;
                if (isBoss) { x = GAME_WIDTH/2 - 40; y = 100; }
                else {
                    if (edge===0) { x=Math.random()*GAME_WIDTH; y=-50; }
                    else if (edge===1) { x=GAME_WIDTH+50; y=Math.random()*GAME_HEIGHT; }
                    else if (edge===2) { x=Math.random()*GAME_WIDTH; y=GAME_HEIGHT+50; }
                    else { x=-50; y=Math.random()*GAME_HEIGHT; }
                }

                const baseHp = isBoss ? 500 : 40;
                const hp = Math.floor(baseHp + (floorMult * 25));
                
                stateRef.current.enemies.push({
                    id: Math.random(), x, y, type,
                    hp, maxHp: hp,
                    atk: 5 + floorMult * 2,
                    speed: isBoss ? 2 : (2 + Math.random()),
                    width: isBoss ? 96 : 32, height: isBoss ? 96 : 32,
                    isHit: 0,
                    color: isBoss ? '#ef4444' : (type==='SLIME'?'#4ade80': type==='GOBLIN'?'#166534':'#b91c1c')
                });

                if (isBoss) {
                    setBossActive(true);
                    playSound('skill');
                    addLog(`⚠️ ${floorMult}층 보스 출현!`);
                }
            };

            const handleDash = () => {
                const now = Date.now();
                if (now - stateRef.current.lastDash < 1000) return;
                const p = stateRef.current.player;
                stateRef.current.lastDash = now;
                stateRef.current.invincible = 20;
                playSound('dash');
                let dx=0, dy=0;
                const dashPower = 150;
                if (p.direction === 'up') dy = -dashPower;
                else if (p.direction === 'down') dy = dashPower;
                else if (p.direction === 'left') dx = -dashPower;
                else dx = dashPower;
                p.x = Math.max(0, Math.min(GAME_WIDTH - PLAYER_SIZE, p.x + dx));
                p.y = Math.max(0, Math.min(GAME_HEIGHT - PLAYER_SIZE, p.y + dy));
                spawnParticle(p.x, p.y, 'text', 'DASH!', '#fff');
            };

            const shootProjectile = (angle, count = 1, spread = 0.2) => {
                const p = stateRef.current.player;
                const stats = getStats();
                const speed = 12;
                for(let i=0; i<count; i++) {
                    const finalAngle = angle + (i - (count-1)/2) * spread;
                    stateRef.current.projectiles.push({
                        id: Math.random(),
                        x: p.x + PLAYER_SIZE/2, y: p.y + PLAYER_SIZE/2,
                        vx: Math.cos(finalAngle) * speed, vy: Math.sin(finalAngle) * speed,
                        life: 40,
                        color: p.classType === 'wizard' ? '#c084fc' : '#fff',
                        damage: stats.atk,
                        isPierce: p.artifacts.includes('multishot')
                    });
                }
                playSound('shoot');
            };

            const handleAttack = () => {
                const now = Date.now();
                const p = stateRef.current.player;
                const cooldown = p.classType === 'assassin' ? 200 : 350;
                if (now - stateRef.current.lastShot < cooldown) return;
                stateRef.current.lastShot = now;

                const stats = getStats();
                const projCount = p.artifacts.includes('multishot') ? (p.classType==='hunter'? 3 : 2) : 1;
                
                const nearest = getNearestEnemy();
                let attackAngle = 0;
                if (nearest) {
                    const dx = (nearest.x + nearest.width/2) - (p.x + PLAYER_SIZE/2);
                    const dy = (nearest.y + nearest.height/2) - (p.y + PLAYER_SIZE/2);
                    attackAngle = Math.atan2(dy, dx);
                    if (Math.abs(dx) > Math.abs(dy)) p.direction = dx > 0 ? 'right' : 'left';
                    else p.direction = dy > 0 ? 'down' : 'up';
                } else {
                    if (p.direction === 'right') attackAngle = 0;
                    else if (p.direction === 'down') attackAngle = Math.PI / 2;
                    else if (p.direction === 'left') attackAngle = Math.PI;
                    else if (p.direction === 'up') attackAngle = -Math.PI / 2;
                }

                if (p.classType === 'knight' || p.classType === 'assassin') {
                    let hx = p.x, hy = p.y, hw = 48, hh = 48;
                    if (nearest) {
                        hx = p.x + Math.cos(attackAngle) * 40;
                        hy = p.y + Math.sin(attackAngle) * 40;
                    } else {
                         if (p.direction === 'left') hx -= 40;
                         if (p.direction === 'right') hx += 40;
                         if (p.direction === 'up') hy -= 40;
                         if (p.direction === 'down') hy += 40;
                    }
                    let hit = false;
                    stateRef.current.enemies.forEach(e => {
                        if (hx < e.x + e.width + 20 && hx + hw > e.x - 20 && 
                            hy < e.y + e.height + 20 && hy + hh > e.y - 20) {
                            let dmg = stats.atk;
                            let isCrit = false;
                            if (p.classType === 'assassin' && Math.random() < 0.3) { dmg *= 2.5; isCrit = true; }
                            e.hp -= dmg; e.isHit = 5;
                            spawnParticle(e.x, e.y, 'dmg', Math.floor(dmg), isCrit ? '#f43f5e' : '#fff');
                            hit = true;
                            if (p.artifacts.includes('vampire')) p.hp = Math.min(p.maxHp, p.hp + 3);
                        }
                    });
                    if (hit) playSound('hit');
                } else {
                    shootProjectile(attackAngle, projCount, 0.3);
                }
            };

            const handleSkill = () => {
                const now = Date.now();
                const p = stateRef.current.player;
                if (now - stateRef.current.lastSkill < 5000) { addLog("스킬 쿨타임!"); return; }
                if (p.mp < 20) { addLog("마나 부족!"); return; }

                p.mp -= 20;
                stateRef.current.lastSkill = now;
                playSound('skill');
                const stats = getStats();

                if (p.classType === 'knight') {
                    stateRef.current.invincible = 180;
                    addLog("디바인 쉴드 발동!");
                } 
                else if (p.classType === 'hunter') {
                    addLog("화살비!");
                    for(let i=0; i<20; i++) {
                        setTimeout(() => {
                            const tx = Math.random() * GAME_WIDTH;
                            const ty = Math.random() * GAME_HEIGHT;
                            spawnParticle(tx, ty, 'text', '⬇', '#4ade80');
                            stateRef.current.enemies.forEach(e => {
                                if(Math.random() < 0.3) { e.hp -= stats.atk * 0.5; e.isHit = 3; }
                            });
                        }, i * 100);
                    }
                } 
                else if (p.classType === 'wizard') {
                    addLog("체인 라이트닝!");
                    const targets = stateRef.current.enemies.filter(e => e.x > 0 && e.x < GAME_WIDTH && e.y > 0 && e.y < GAME_HEIGHT);
                    if (targets.length > 0) {
                        let curr = targets[0];
                        for(let i=0; i<5; i++) {
                            if (!curr) break;
                            curr.hp -= stats.atk * 2; curr.isHit = 10;
                            spawnParticle(curr.x, curr.y, 'text', '⚡', '#c084fc');
                            curr = targets.find(t => t !== curr && Math.abs(t.x - curr.x) < 200);
                        }
                    }
                }
                else if (p.classType === 'assassin') {
                    const target = stateRef.current.enemies[0];
                    if (target) {
                        p.x = target.x - 40; p.y = target.y;
                        target.hp -= stats.atk * 5; target.isHit = 10;
                        spawnParticle(target.x, target.y, 'text', 'CRITICAL!', '#f43f5e');
                        addLog("그림자 습격!");
                    } else {
                        addLog("타겟 없음"); p.mp += 20;
                    }
                }
            };

            useEffect(() => {
                if (gameState !== 'PLAYING') return;

                const loop = () => {
                    if (!stateRef.current.gameActive) {
                        loopRef.current = requestAnimationFrame(loop);
                        return;
                    }

                    const p = stateRef.current.player;
                    const keys = stateRef.current.keys;
                    const stats = getStats();
                    
                    let dx = 0, dy = 0;
                    if (keys['ArrowUp'] || keys['w']) { dy = -stats.speed; p.direction = 'up'; }
                    if (keys['ArrowDown'] || keys['s']) { dy = stats.speed; p.direction = 'down'; }
                    if (keys['ArrowLeft'] || keys['a']) { dx = -stats.speed; p.direction = 'left'; }
                    if (keys['ArrowRight'] || keys['d']) { dx = stats.speed; p.direction = 'right'; }

                    p.x = Math.max(0, Math.min(GAME_WIDTH - PLAYER_SIZE, p.x + dx));
                    p.y = Math.max(0, Math.min(GAME_HEIGHT - PLAYER_SIZE, p.y + dy));

                    if (stateRef.current.invincible > 0) {
                        stateRef.current.invincible--;
                        if (p.classType === 'knight' && stateRef.current.invincible % 10 === 0) {
                            stateRef.current.enemies.forEach(e => {
                                if (Math.abs(e.x - p.x) < 100 && Math.abs(e.y - p.y) < 100) {
                                    e.hp -= stats.atk * 0.2; e.isHit = 2;
                                }
                            });
                        }
                    }
                    if (p.mp < p.maxMp) p.mp += p.artifacts.includes('mana') ? 0.2 : 0.1;

                    stateRef.current.projectiles = stateRef.current.projectiles.filter(proj => {
                        proj.x += proj.vx; proj.y += proj.vy; proj.life--;
                        let hit = false;
                        for (let e of stateRef.current.enemies) {
                            if (proj.x > e.x && proj.x < e.x + e.width && proj.y > e.y && proj.y < e.y + e.height) {
                                e.hp -= proj.damage; e.isHit = 5;
                                spawnParticle(e.x, e.y, 'dmg', Math.floor(proj.damage), '#fff');
                                hit = true;
                                if (!proj.isPierce) break; 
                            }
                        }
                        return proj.life > 0 && (!hit || proj.isPierce);
                    });

                    let enemiesAlive = [];
                    stateRef.current.enemies.forEach(e => {
                        if (e.hp <= 0) {
                            const goldDrop = Math.floor(Math.random() * 10 * stateRef.current.floor) + 5;
                            p.gold += goldDrop; p.exp += 25 * stateRef.current.floor;
                            spawnParticle(e.x, e.y, 'text', `+${goldDrop}G`, 'gold');
                            playSound('coin');

                            if (p.exp >= p.maxExp) {
                                p.level++; p.exp -= p.maxExp;
                                p.maxExp = Math.floor(p.maxExp * 1.3);
                                p.maxHp += 20; p.hp = p.maxHp; p.atk += 3;
                                playSound('levelup'); spawnParticle(p.x, p.y, 'text', 'LEVEL UP!', '#fbbf24');
                                addLog(`레벨업! Lv.${p.level}`);
                            }
                            if (e.type === 'BOSS') {
                                setBossActive(false); setFloor(f => f + 1); stateRef.current.floor++;
                                p.hp = p.maxHp; addLog(`✅ 층 클리어! 상점이 열립니다.`);
                                openShop();
                            }
                            return;
                        }

                        const dx = p.x - e.x; const dy = p.y - e.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist > 5) { e.x += (dx/dist) * e.speed; e.y += (dy/dist) * e.speed; }

                        if (dist < 30 && stateRef.current.invincible <= 0) {
                            if (Math.random() < 0.05) {
                                p.hp -= e.atk; p.isHit = 10;
                                spawnParticle(p.x, p.y, 'dmg', `-${e.atk}`, 'red');
                                playSound('hit');
                                if (p.hp <= 0) {
                                    setGameState('DEAD'); stateRef.current.gameActive = false;
                                }
                            }
                        }
                        if (e.isHit > 0) e.isHit--;
                        enemiesAlive.push(e);
                    });
                    stateRef.current.enemies = enemiesAlive;

                    const maxEnemies = 5 + Math.floor(stateRef.current.floor / 2);
                    if (!bossActive && stateRef.current.gameActive && gameState === 'PLAYING') {
                        if (Math.random() < 0.02 && enemiesAlive.length < maxEnemies) spawnEnemy(false);
                    }
                    if (stateRef.current.enemies.length === 0 && !bossActive && Math.random() < 0.005) spawnEnemy(true);

                    stateRef.current.particles = stateRef.current.particles.filter(pt => {
                        pt.x += pt.vx; pt.y += pt.vy; pt.life--;
                        return pt.life > 0;
                    });

                    setPlayer({...p});
                    setEnemies([...stateRef.current.enemies]);
                    setProjectiles([...stateRef.current.projectiles]);
                    setParticles([...stateRef.current.particles]);

                    loopRef.current = requestAnimationFrame(loop);
                };

                loopRef.current = requestAnimationFrame(loop);
                
                const onKey = (e, v) => {
                    const key = e.key.toLowerCase();
                    stateRef.current.keys[e.key] = v;
                    stateRef.current.keys[key] = v;
                    
                    if (v && gameState === 'PLAYING') {
                        if (key === ' ') handleDash();
                        if (key === 'k') handleAttack();
                        if (key === 'l' || key === '1') handleSkill();
                    }
                };

                window.addEventListener('keydown', e => onKey(e, true));
                window.addEventListener('keyup', e => onKey(e, false));

                return () => {
                    cancelAnimationFrame(loopRef.current);
                    window.removeEventListener('keydown', e => onKey(e, true));
                    window.removeEventListener('keyup', e => onKey(e, false));
                };
            }, [gameState, bossActive]);

            // Helper for D-Pad events (supports both touch and mouse)
            const bindDPad = (key) => ({
                onTouchStart: (e) => { e.preventDefault(); stateRef.current.keys[key] = true; },
                onTouchEnd: (e) => { e.preventDefault(); stateRef.current.keys[key] = false; },
                onMouseDown: (e) => { e.preventDefault(); stateRef.current.keys[key] = true; },
                onMouseUp: (e) => { e.preventDefault(); stateRef.current.keys[key] = false; },
                onMouseLeave: (e) => { e.preventDefault(); stateRef.current.keys[key] = false; }
            });

            // --- Render ---
            if (gameState === 'SELECT_CLASS') {
                return (
                    <div className="w-full h-full flex flex-col items-center justify-center bg-gray-900 p-4">
                        <h1 className="text-4xl mb-8 font-bold text-yellow-400 pixel-art text-center">직업을 선택하세요</h1>
                        <div className="grid grid-cols-2 gap-4 max-w-2xl w-full">
                            {Object.entries(CLASSES).map(([key, cls]) => (
                                <button key={key} onClick={() => initGame(key)} 
                                    className="p-6 border-2 border-gray-600 hover:border-white rounded bg-gray-800 flex flex-col items-center transition-all hover:scale-105 active:scale-95">
                                    <div className="w-16 h-16 rounded mb-4 flex items-center justify-center" style={{ backgroundColor: cls.color }}>
                                        {cls.weapon === 'sword' && <Icons.Sword size={40} />}
                                        {cls.weapon === 'bow' && <Icons.Bow size={40} />}
                                        {cls.weapon === 'staff' && <Icons.Staff size={40} />}
                                        {cls.weapon === 'dagger' && <Icons.Dagger size={40} />}
                                    </div>
                                    <h2 className="text-xl font-bold mb-2" style={{ color: cls.color }}>{cls.name}</h2>
                                    <p className="text-sm text-gray-400 mb-2 text-center">{cls.desc}</p>
                                </button>
                            ))}
                        </div>
                    </div>
                );
            }

            if (gameState === 'DEAD') {
                return (
                    <div className="w-full h-full flex flex-col items-center justify-center bg-red-900/50">
                        <Icons.Skull size={64} className="mb-4 text-white shake" />
                        <h1 className="text-6xl font-bold mb-4">GAME OVER</h1>
                        <p className="text-xl mb-8">당신은 {floor}층에서 쓰러졌습니다.</p>
                        <button onClick={resetGame} className="px-8 py-3 bg-white text-black font-bold rounded hover:bg-gray-200 flex items-center gap-2">
                            <Icons.RotateCcw size={20} /> 처음으로
                        </button>
                    </div>
                );
            }

            const biome = getBiomeStyle(floor);
            let nearestEnemyId = null;
            if (enemies.length > 0) {
                let minD = Infinity;
                enemies.forEach(e => {
                     const dx = (e.x + e.width/2) - (player.x + PLAYER_SIZE/2);
                     const dy = (e.y + e.height/2) - (player.y + PLAYER_SIZE/2);
                     const d = dx*dx + dy*dy;
                     if (d < minD) { minD = d; nearestEnemyId = e.id; }
                });
            }

            return (
                <div ref={containerRef} className="relative w-full h-full overflow-hidden" 
                    style={{ backgroundColor: biome.bg }}>
                    
                    {/* Background Grid */}
                    <div className="absolute inset-0 bg-pattern opacity-20 pointer-events-none" />

                    {/* Game Layer with Enhanced Borders */}
                    <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2"
                        style={{ 
                            width: GAME_WIDTH, 
                            height: GAME_HEIGHT, 
                            border: `24px solid ${biome.wall}`, 
                            boxShadow: 'inset 0 0 50px rgba(0,0,0,0.8), 0 0 0 1000px #000' 
                        }}>
                        
                        {particles.map(pt => (
                            <div key={pt.id} className="absolute pointer-events-none"
                                style={{ 
                                    left: pt.x, top: pt.y, color: pt.color,
                                    fontSize: pt.type === 'dmg' ? '20px' : '14px',
                                    fontWeight: 'bold', textShadow: '1px 1px 0 #000'
                                }}>
                                {pt.type === 'dmg' ? pt.value : pt.value}
                            </div>
                        ))}

                        {projectiles.map(pr => (
                            <div key={pr.id} className="absolute rounded-full"
                                style={{ 
                                    left: pr.x, top: pr.y, width: 8, height: 8, 
                                    backgroundColor: pr.color, boxShadow: `0 0 5px ${pr.color}` 
                                }} />
                        ))}

                        {enemies.map(en => (
                            <div key={en.id} className={`absolute transition-transform ${en.isHit > 0 ? 'brightness-200 scale-110' : ''}`}
                                style={{ 
                                    left: en.x, top: en.y, width: en.width, height: en.height, 
                                    backgroundColor: en.color,
                                    borderRadius: en.type === 'SLIME' ? '50% 50% 0 0' : '4px'
                                }}>
                                {nearestEnemyId === en.id && (
                                    <div className="absolute -top-10 left-1/2 -translate-x-1/2 text-red-500 target-indicator pointer-events-none z-10">
                                        <Icons.Target size={32} />
                                    </div>
                                )}
                                <div className="absolute -top-3 left-0 w-full h-1 bg-red-900">
                                    <div className="h-full bg-red-500" style={{ width: `${(en.hp / en.maxHp) * 100}%` }} />
                                </div>
                                <div className="absolute top-1/4 left-1/4 w-1 h-1 bg-black opacity-50" />
                                <div className="absolute top-1/4 right-1/4 w-1 h-1 bg-black opacity-50" />
                            </div>
                        ))}

                        <div className={`absolute transition-transform ${stateRef.current.invincible > 0 ? 'opacity-50' : ''}`}
                            style={{ 
                                left: player.x, top: player.y, width: PLAYER_SIZE, height: PLAYER_SIZE, 
                                color: CLASSES[player.classType].color 
                            }}>
                            {player.classType === 'knight' && <Icons.Sword className="w-full h-full" />}
                            {player.classType === 'hunter' && <Icons.Bow className="w-full h-full" />}
                            {player.classType === 'wizard' && <Icons.Staff className="w-full h-full" />}
                            {player.classType === 'assassin' && <Icons.Dagger className="w-full h-full" />}
                            {stateRef.current.invincible > 0 && <div className="absolute -inset-2 border-2 border-yellow-400 rounded-full animate-pulse" />}
                        </div>
                    </div>

                    {/* UI HUD */}
                    <div className="absolute top-0 left-0 w-full p-4 flex justify-between items-start pointer-events-none z-20">
                        <div className="bg-black/50 p-2 rounded backdrop-blur-sm border border-gray-700">
                            <div className="flex items-center gap-2 mb-1">
                                <span className="text-yellow-400 font-bold">Lv.{player.level}</span>
                                <span className="text-white">{CLASSES[player.classType].name}</span>
                            </div>
                            <div className="w-32 h-3 bg-gray-800 mb-1 rounded overflow-hidden">
                                <div className="h-full bg-red-500 transition-all" style={{ width: `${(player.hp / player.maxHp) * 100}%` }} />
                            </div>
                            <div className="w-32 h-3 bg-gray-800 mb-1 rounded overflow-hidden">
                                <div className="h-full bg-blue-500 transition-all" style={{ width: `${(player.mp / player.maxMp) * 100}%` }} />
                            </div>
                            <div className="w-32 h-1 bg-gray-800 rounded overflow-hidden mt-1">
                                <div className="h-full bg-yellow-500" style={{ width: `${(player.exp / player.maxExp) * 100}%` }} />
                            </div>
                        </div>

                        <div className="flex flex-col items-end gap-2">
                             <div className="bg-black/50 p-2 rounded text-right backdrop-blur-sm border border-gray-700">
                                <div className="text-2xl font-bold">{floor}F</div>
                                <div className="text-yellow-400 flex items-center justify-end gap-1">
                                    <Icons.Coin size={16} /> {player.gold}
                                </div>
                            </div>
                            <div className="w-64 flex flex-col gap-1 items-end">
                                {logs.map((l, i) => (
                                    <div key={i} className="text-sm text-white/80 bg-black/30 px-2 py-1 rounded">{l}</div>
                                ))}
                            </div>
                        </div>
                    </div>
                    
                    <div className="absolute bottom-20 left-4 flex gap-2 z-20">
                        {player.artifacts.map((artId, i) => {
                            const art = ARTIFACTS.find(a => a.id === artId);
                            if (!art) return null;
                            return (
                                <div key={i} className="w-8 h-8 bg-black/60 border border-gray-600 rounded flex items-center justify-center text-xs" title={art.name}>
                                    <art.icon size={16} color={art.color} />
                                </div>
                            );
                        })}
                    </div>

                    {showShop && (
                        <div className="absolute inset-0 bg-black/80 flex items-center justify-center z-50 p-4 pointer-events-auto">
                            <div className="bg-gray-800 border-2 border-yellow-600 rounded-lg p-6 max-w-lg w-full">
                                <div className="flex justify-between items-center mb-6">
                                    <h2 className="text-2xl font-bold text-yellow-400 flex items-center gap-2"><Icons.Shop /> 던전 상점</h2>
                                    <button onClick={closeShop} className="p-1 hover:bg-gray-700 rounded"><Icons.X /></button>
                                </div>
                                <div className="space-y-4">
                                    {shopItems.length === 0 ? <p className="text-gray-400 text-center py-8">품절되었습니다.</p> : shopItems.map((item, idx) => (
                                        <div key={idx} className="flex items-center justify-between bg-gray-900 p-3 rounded border border-gray-700">
                                            <div className="flex items-center gap-3">
                                                <div className="w-10 h-10 rounded bg-gray-800 flex items-center justify-center">
                                                    {item.icon && <item.icon size={24} color={item.color} />}
                                                </div>
                                                <div>
                                                    <div className="font-bold">{item.name}</div>
                                                    <div className="text-xs text-gray-400">{item.desc}</div>
                                                </div>
                                            </div>
                                            <button onClick={() => buyItem(item)} className="px-4 py-2 bg-yellow-700 hover:bg-yellow-600 rounded text-sm font-bold flex items-center gap-1">
                                                <Icons.Coin size={14} /> {item.cost}
                                            </button>
                                        </div>
                                    ))}
                                </div>
                                <div className="mt-6 text-right text-yellow-400 font-bold">보유 골드: {player.gold}G</div>
                            </div>
                        </div>
                    )}

                    {/* Mobile Controls */}
                    <div className="absolute bottom-8 left-8 z-40">
                        <div className="relative w-32 h-32 bg-white/5 rounded-full backdrop-blur-sm border border-white/10">
                            <button className="d-pad-btn absolute top-2 left-1/2 -translate-x-1/2 w-10 h-10" 
                                {...bindDPad('ArrowUp')}>
                                <Icons.ArrowUp />
                            </button>
                            <button className="d-pad-btn absolute bottom-2 left-1/2 -translate-x-1/2 w-10 h-10" 
                                {...bindDPad('ArrowDown')}>
                                <Icons.ArrowDown />
                            </button>
                            <button className="d-pad-btn absolute left-2 top-1/2 -translate-y-1/2 w-10 h-10" 
                                {...bindDPad('ArrowLeft')}>
                                <Icons.ArrowLeft />
                            </button>
                            <button className="d-pad-btn absolute right-2 top-1/2 -translate-y-1/2 w-10 h-10" 
                                {...bindDPad('ArrowRight')}>
                                <Icons.ArrowRight />
                            </button>
                        </div>
                    </div>

                    <div className="absolute bottom-8 right-8 z-40 grid grid-cols-2 gap-4">
                        <button className="action-btn w-14 h-14 bg-blue-500/80 text-white" 
                            onClick={handleDash}>
                            <Icons.Wind size={24} />
                        </button>
                        <button className="action-btn w-16 h-16 bg-red-600/80 text-white transform -translate-y-4" 
                            onTouchStart={(e)=>{e.preventDefault(); handleAttack();}}
                            onMouseDown={(e)=>{e.preventDefault(); handleAttack();}}>
                            <Icons.Sword size={32} />
                        </button>
                        <button className="action-btn w-14 h-14 bg-purple-500/80 text-white" 
                            onClick={handleSkill}>
                            <Icons.Zap size={24} />
                        </button>
                        <button className="action-btn w-12 h-12 bg-green-500/80 text-white" 
                             onClick={() => { /* Potion Placeholder */ }}>
                            <Icons.Heart size={20} />
                        </button>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>